@use "@scss/class/mixins.scss" as m;

//
@property --order { syntax: "<integer>"; initial-value: 1; inherits: true; };
@property --content-inline-size { syntax: "<length-percentage>"; initial-value: 100%; inherits: true; };
@property --content-block-size  { syntax: "<length-percentage>"; initial-value: 100%; inherits: true; };

//
@layer ux-classes {
    //
    .grid-rows, :host(.grid-rows) {
        @include m.grid-flow(row);
        @include m.place();

        //
        & {
            grid-auto-rows: minmax(0px, max-content);
            grid-template-columns: minmax(0px, 1fr);
        }

        //
        & { @include m.size(max-content, max-content); }
        & > *, & > ::slotted(*) { @include m.grid-row; }
    }

    //
    .grid-columns, :host(.grid-columns) {
        @include m.grid-flow(column);
        @include m.place();

        //
        & {
            grid-auto-columns: minmax(0px, 1fr);
            grid-template-rows: minmax(0px, 1fr);
        }

        //
        & > *, & > ::slotted(*) { @include m.grid-column; }
    }

    //
    .flex-columns, :host(.flex-columns) {
        @include m.flex-flow(row);
        @include m.place();

        //
        & > *, & > ::slotted(*) { @include m.flex-column; }
    }

    //
    .grid-layered, :host(.grid-layered) {
        & {
            grid-template-columns: minmax(0px, 1fr);
            grid-template-rows: minmax(0px, 1fr);
        }

        //
        & {
            @include m.display();
            @include m.size(max-content, max-content);
        }

        //
        & > *, & > ::slotted(*) {
            --order: m.sibling-index();

            //
            order: var(--order, auto);
            z-index: var(--order, 0);
            grid-column: 1 / -1;
            grid-row   : 1 / -1;

            //
            @include m.size(auto, auto);
        }
    }

    //
    .grid-rows-3c, :host(.grid-rows-3c) { // hovewer, would be 'grid-columns-count' variable...
        @include m.grid-template-columns(minmax(0px, max-content) minmax(0px, 1fr) minmax(0px, max-content));

        //
        & > *, & > ::slotted(*) {
            // would be say in very hard native CSS combinatoric:
            // if var(--order, 1) == sibling-count() ? 3 : var(--order, 1)
            & > *, & > ::slotted(*) { --order: m.sibling-index(); grid-column: var(--order, 1) / var(--order, 1) span; }
            & > *:last-child, & > ::slotted(*:last-child) { grid-column: var(--order, 1) / 3 span; }
        }
    }

    //
    .stretch-inline {
        inline-size: 100%;
        inline-size: -webkit-fill-available;
        inline-size: stretch;
    }

    //
    .stretch-block {
        block-size: 100%;
        block-size: -webkit-fill-available;
        block-size: stretch;
    }

    // requires `box-sizing: border-box`
    .content-inline-size {
        padding-inline: limit-by-size(calc(var(--content-inline-size, 100%) * 0.5), 100%);
    }

    // requires `box-sizing: border-box`
    .content-block-size {
        padding-block: limit-by-size(calc(var(--content-block-size, 100%) * 0.5), 100%);
    }

    //
    .time-format {
        // font styles
        font-size: 1em;
        font-optical-sizing: auto;
        font-variant-numeric: tabular-nums;
        font-weight: 500;
        font-kerning: auto;
        font-family: 'Fira Mono', 'Menlo', 'Consolas', monospace;
        font-stretch: condensed;
        font-width: condensed;

        // text styles
        letter-spacing: -0.05em;
        text-overflow: ellipsis;
        text-overflow: "";

        // text layout
        text-align: center;
        white-space: nowrap;

        //
        flex-direction: row;

        // IDK, where put direction, after display or end of mixin?
        @include m.display(inline flex, center, center);
        @include m.size(max-content, max-content);
    }
}
